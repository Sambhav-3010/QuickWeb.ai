# WebContainer Implementation Guide (No External UI Dependencies)

This guide details how to integrate WebContainers into your Next.js project to run the generated code in the browser, using standard HTML/CSS for logs instead of heavy terminal libraries.

## 1. Prerequisites (Install Dependencies)

Run the following command in your terminal to install the necessary package:

```bash
npm install @webcontainer/api
```

## 2. Server Configuration (CRITICAL)

WebContainers require specific Cross-Origin headers to work (SharedArrayBuffer).
Update your `next.config.mjs` to include these headers:

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  typescript: {
    ignoreBuildErrors: true,
  },
  images: {
    unoptimized: true,
  },
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          {
            key: 'Cross-Origin-Opener-Policy',
            value: 'same-origin',
          },
          {
            key: 'Cross-Origin-Embedder-Policy',
            value: 'require-corp',
          },
        ],
      },
    ];
  },
}

export default nextConfig
```

## 3. The Hook: `hooks/useWebContainers.ts`

Update your existing hook to properly manage the WebContainer instance and boot process.

```typescript
import { useEffect, useState, useRef } from "react";
import { WebContainer } from "@webcontainer/api";

export const useWebContainer = () => {
  const [webcontainer, setWebcontainer] = useState<WebContainer | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  
  // Use a ref to ensure we only boot once
  const bootStartedRef = useRef(false);

  useEffect(() => {
    async function boot() {
      if (bootStartedRef.current) return;
      bootStartedRef.current = true;

      try {
        const instance = await WebContainer.boot();
        setWebcontainer(instance);
        setIsLoading(false);
      } catch (err) {
        console.error("Failed to boot WebContainer:", err);
        setError(err as Error);
        setIsLoading(false);
      }
    }

    boot();
  }, []);

  return { webcontainer, isLoading, error };
};
```

## 4. The Terminal Component: `components/terminal-panel.tsx`

Create a simple component to display the installation and server logs using a standard ScrollArea or div. This replaces the complex xterm implementation.

```tsx
"use client";

import { useEffect, useRef } from "react";
import { ScrollArea } from "@/components/ui/scroll-area";

interface TerminalPanelProps {
  logs: string[];
}

export function TerminalPanel({ logs }: TerminalPanelProps) {
  const scrollRef = useRef<HTMLDivElement>(null);

  // Auto-scroll to bottom when logs update
  useEffect(() => {
    if (scrollRef.current) {
        scrollRef.current.scrollIntoView({ behavior: "smooth", block: "end" });
    }
  }, [logs]);

  return (
    <div className="h-full w-full bg-[#1e1e1e] rounded-lg border border-border overflow-hidden flex flex-col">
       <div className="flex items-center px-4 py-2 border-b border-white/10 bg-white/5">
         <div className="flex gap-1.5">
           <div className="w-3 h-3 rounded-full bg-red-500/80" />
           <div className="w-3 h-3 rounded-full bg-yellow-500/80" />
           <div className="w-3 h-3 rounded-full bg-green-500/80" />
         </div>
         <span className="ml-3 text-xs text-muted-foreground font-mono">Terminal Output</span>
       </div>
       <ScrollArea className="flex-1 p-4">
        <div className="font-mono text-sm text-gray-300 whitespace-pre-wrap">
          {logs.map((log, i) => (
            <span key={i}>{log}</span>
          ))}
          <div ref={scrollRef} />
        </div>
      </ScrollArea>
    </div>
  );
}
```

## 5. Integration: Update `app/generate/page.tsx`

This is where the logic comes together. You need to:
1. Boot the container.
2. Mount the generated files.
3. Install dependencies (`npm install`).
4. Start the dev server (`npm run dev`).

Here is the plan for `GeneratePage` modifications (add this logic inside the component):

```tsx
// Imports
import { useWebContainer } from "@/hooks/useWebContainers"; 
import { TerminalPanel } from "@/components/terminal-panel";
import { convertToFileSystemTree } from "@/lib/utils"; // You'll implement this helper below
// ... other imports ...

export default function GeneratePage() {
  // Existing state ...
  const { webcontainer, isLoading: isContainerLoading } = useWebContainer();
  const [previewUrl, setPreviewUrl] = useState("");
  const [logs, setLogs] = useState<string[]>([]); // State for terminal logs

  // ... exisiting effects ...

  // NEW EFFECT: Handle WebContainer Logic
  useEffect(() => {
    // Only start if we have a container, files, and haven't already started (check previewUrl or a ref)
    if (!webcontainer || !project?.fileTree || previewUrl) return;

    async function startContainer() {
      setLogs(prev => [...prev, "Starting WebContainer...\n"]);

      // 1. Mount Files
      setLogs(prev => [...prev, "Mounting files...\n"]);
      const fileSystemTree = convertToFileSystemTree(project.fileTree); 
      await webcontainer.mount(fileSystemTree);

      // 2. Install Dependencies
      setLogs(prev => [...prev, "Running npm install...\n"]);
      const installProcess = await webcontainer.spawn('npm', ['install']);
      
      installProcess.output.pipeTo(new WritableStream({
        write(data) {
          setLogs(prev => [...prev, data]);
        }
      }));

      const installExitCode = await installProcess.exit;
      if (installExitCode !== 0) {
         setLogs(prev => [...prev, "\nInstallation failed! Check logs above.\n"]);
        return;
      }

      setLogs(prev => [...prev, "\nInstallation complete.\nStarting dev server...\n"]);

      // 3. Start Dev Server
      const devProcess = await webcontainer.spawn('npm', ['run', 'dev']);

      devProcess.output.pipeTo(new WritableStream({
        write(data) {
           setLogs(prev => [...prev, data]);
        }
      }));

      // 4. Listen for Server Ready
      webcontainer.on('server-ready', (port, url) => {
        setLogs(prev => [...prev, `\nServer ready at: ${url}\n`]);
        setPreviewUrl(url); 
        
        // Update project state with preview URL so it persists
        setProject(prev => prev ? { ...prev, previewUrl: url } : null);
      });
    }

    startContainer();
  }, [webcontainer, project?.fileTree, previewUrl]);

  // ... render ...
  // Pass 'logs' to your TerminalPanel or prompt panel where you want to show it.
}
```

## Helper Function: Convert File Tree

You need a utility to convert your app's file structure to what WebContainer expects.

```typescript
// Add to lib/utils.ts

export function convertToFileSystemTree(files: any[]): any {
  const tree: any = {};
  
  // Example recursive function assuming your files have { path, content } or similar
  // You need to adapt this to match your exact 'FileItem' or 'Step' type structure.
  
  /* 
  files.forEach(file => {
      // Split path 'components/ui/button.tsx' -> ['components', 'ui', 'button.tsx']
      const parts = file.path.split('/');
      let current = tree;
      
      for (let i = 0; i < parts.length; i++) {
          const part = parts[i];
          const isFile = i === parts.length - 1;
          
          if (isFile) {
              current[part] = {
                  file: { contents: file.content }
              };
          } else {
              if (!current[part]) {
                  current[part] = { directory: {} };
              }
              current = current[part].directory;
          }
      }
  });
  */
  
  return tree;
}
```

## 6. Running it in the Preview

In `GeneratePage`, pass the `previewUrl` state to the `CodePreviewToggle` component.

```tsx
<CodePreviewToggle
  content={selectedFile?.content ?? ""}
  fileName={selectedFile?.name ?? ""}
  previewUrl={previewUrl}
  view={view}
  onViewChange={setView}
/>
```
